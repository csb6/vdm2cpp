module Foo
exports all
definitions

types
    Named = nat;
    Union = Record | Named;
    Product = nat * Named;
    Record :: a : nat1
              b : seq of char
              c : Named
              d : rat
              e : int
              f : real
              g : <A>;
    Optional = [nat];
    Set = set of char;
    Set1 = set1 of char;
    Seq = seq of char;
    Seq1 = seq1 of char;
    Map = map nat to char;
    InjectiveMap = inmap nat to char;
    Function = char -> char;
functions
    ident: char -> char
    ident(c) == c;

end Foo