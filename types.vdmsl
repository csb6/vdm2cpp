module Foo
exports all
definitions

types
    Named = nat;
    Union = Record | Named;
    Product = nat * Named;
    Record :: a : nat1
              b : seq of char
              c : Named
              d : rat
              e : int
              f : real
              g : <A>;
    Optional = [nat];
    Set = set of char;
    Set1 = set1 of char;
    Seq = seq of char;
    Seq1 = seq1 of char;
    Map = map nat to char;
    InjectiveMap = inmap nat to char;
    Function = char -> char;
functions
    ident: char -> char
    ident(c) == c;

    two_args: char * char -> nat1
    two_args(-, -) == 4;

    string_lit: seq of char -> seq of char
    string_lit(-) == "Hello, world";

    unary_op: int -> int
    unary_op(a) == -a;

    binary_ops: int * int * int -> int
    binary_ops(a,b,c) == (a + 1 * -b + 0) / c;
end Foo